diff --git a/.gitignore b/.gitignore
index 7da4c87..afaf347 100644
--- a/.gitignore
+++ b/.gitignore
@@ -22,4 +22,13 @@ Thumbs.db
 
 # Build artifacts
 *.log
-coverage/
\ No newline at end of file
+coverage/
+
+# Local build directories
+build/
+packages/core/build/
+# python build outputs
+packages/core/build/
+dist/
+*.egg-info/
+
diff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml
index 0f8c214..1fdc6ec 100644
--- a/.pre-commit-config.yaml
+++ b/.pre-commit-config.yaml
@@ -3,5 +3,13 @@ repos:
     rev: 24.4.2
     hooks: [{id: black}]
   - repo: https://github.com/astral-sh/ruff-pre-commit
-    rev: v0.5.6
-    hooks: [{id: ruff}]
\ No newline at end of file
+    rev: v0.5.5
+    hooks:
+      - id: ruff
+        args: ["--fix", "--exit-non-zero-on-fix"]
+        exclude: |
+          (?x)(
+            ^packages/core/build/|
+            ^dist/|
+            \.egg-info/
+          )
\ No newline at end of file
diff --git a/apps/web/src/App.tsx b/apps/web/src/App.tsx
index 2c58bd7..703ded3 100644
--- a/apps/web/src/App.tsx
+++ b/apps/web/src/App.tsx
@@ -2,17 +2,15 @@ import "./App.css";
 import Analysis from "./pages/Analysis";
 import Portfolio from "./pages/Portfolio";
 import Company from "./pages/Company";
-import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
+import { Routes, Route, Navigate } from "react-router-dom";
 
 export default function App() {
   return (
-    <BrowserRouter>
-      <Routes>
-        <Route path="/" element={<Navigate to="/analysis" replace />} />
-        <Route path="/analysis" element={<Analysis />} />
-        <Route path="/portfolio" element={<Portfolio />} />
-        <Route path="/company/:symbol" element={<Company />} />
-      </Routes>
-    </BrowserRouter>
+    <Routes>
+      <Route path="/" element={<Navigate to="/analysis" replace />} />
+      <Route path="/analysis" element={<Analysis />} />
+      <Route path="/portfolio" element={<Portfolio />} />
+      <Route path="/company/:symbol" element={<Company />} />
+    </Routes>
   );
 }
\ No newline at end of file
diff --git a/packages/core/build/lib/core/__init__.py b/packages/core/build/lib/core/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/packages/core/build/lib/core/_legacy_data_fetch.py b/packages/core/build/lib/core/_legacy_data_fetch.py
new file mode 100644
index 0000000..18b1cc0
--- /dev/null
+++ b/packages/core/build/lib/core/_legacy_data_fetch.py
@@ -0,0 +1,425 @@
+import os
+import requests
+import zipfile
+import io
+import pandas as pd
+import time
+import aiohttp
+import asyncio
+import logging
+import numpy as np
+from xml.etree.ElementTree import parse
+from dotenv import load_dotenv
+from datetime import datetime, timedelta
+import json
+
+# --- 기본 설정 ---
+logging.basicConfig(
+    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
+)
+load_dotenv()
+API_KEY = os.getenv("API_KEY")
+APP_KEY = os.getenv("APP_KEY")
+APP_SECRET = os.getenv("APP_SECRET")
+
+if not all([API_KEY, APP_KEY, APP_SECRET]):
+    raise ValueError("API 키가 .env 파일에 올바르게 설정되지 않았습니다.")
+
+CACHE_DIR = "data/cache"
+KIS_BASE_URL = "https://openapi.koreainvestment.com:9443"
+KIS_ACCESS_TOKEN_CACHE = {"token": None, "expires_at": None}
+os.makedirs(CACHE_DIR, exist_ok=True)
+
+
+# --- 캐싱 헬퍼 함수 ---
+def _get_cache_path(cache_type, *args):
+    return os.path.join(CACHE_DIR, cache_type, *[str(a) for a in args])
+
+
+def _is_cache_valid(file_path, duration_days=0):
+    if not os.path.exists(file_path):
+        return False
+    file_mod_time = datetime.fromtimestamp(os.path.getmtime(file_path))
+    return (datetime.now() - file_mod_time) < timedelta(days=duration_days)
+
+
+def _json_default(o):
+    """numpy 숫자를 파이썬 기본형으로 변환"""
+    if isinstance(o, (np.integer,)):
+        return int(o)
+    if isinstance(o, (np.floating,)):
+        return float(o)
+    if isinstance(o, (np.ndarray,)):
+        return o.tolist()
+    raise TypeError(f"{type(o)} is not JSON serializable")
+
+
+def _save_data_to_cache(data, file_path):
+    os.makedirs(os.path.dirname(file_path), exist_ok=True)
+    try:
+        if isinstance(data, pd.DataFrame):
+            data.to_parquet(file_path, index=False)
+        elif isinstance(data, dict):
+            with open(file_path, "w", encoding="utf-8") as f:
+                json.dump(data, f, ensure_ascii=False, indent=4, default=_json_default)
+        logging.info(f"✅ 데이터 캐시 저장: {file_path}")
+    except Exception as e:
+        logging.error(f"❌ 캐시 저장 실패 ({file_path}): {e}")
+
+
+def _load_data_from_cache(file_path):
+    try:
+        if file_path.endswith(".parquet"):
+            return pd.read_parquet(file_path)
+        elif file_path.endswith(".json"):
+            with open(file_path, "r", encoding="utf-8") as f:
+                return json.load(f)
+    except Exception:
+        return None
+
+
+# --- KIS API 공통 함수 ---
+async def _get_kis_access_token_async(session):
+    if (
+        KIS_ACCESS_TOKEN_CACHE["token"]
+        and datetime.now() < KIS_ACCESS_TOKEN_CACHE["expires_at"]
+    ):
+        return KIS_ACCESS_TOKEN_CACHE["token"]
+    url = f"{KIS_BASE_URL}/oauth2/tokenP"
+    body = {
+        "grant_type": "client_credentials",
+        "appkey": APP_KEY,
+        "appsecret": APP_SECRET,
+    }
+    try:
+        async with session.post(
+            url,
+            headers={"Content-Type": "application/json"},
+            data=json.dumps(body),
+            timeout=10,
+        ) as resp:
+            resp.raise_for_status()
+            token_data = await resp.json()
+            if "access_token" in token_data:
+                token = token_data["access_token"]
+                expires_at = datetime.now() + timedelta(
+                    seconds=token_data.get("expires_in", 86400) - 300
+                )
+                KIS_ACCESS_TOKEN_CACHE.update(
+                    {"token": token, "expires_at": expires_at}
+                )
+                return token
+    except Exception as e:
+        logging.error(f"❌ KIS 액세스 토큰 발급 실패: {e}")
+    return None
+
+
+async def _fetch_kis_data(session, url, tr_id, params):
+    token = await _get_kis_access_token_async(session)
+    if not token:
+        return None
+    headers = {
+        "Authorization": f"Bearer {token}",
+        "appkey": APP_KEY,
+        "appsecret": APP_SECRET,
+        "tr_id": tr_id,
+        "custtype": "P",
+    }
+    try:
+        async with session.get(url, headers=headers, params=params, timeout=10) as resp:
+            resp.raise_for_status()
+            data = await resp.json()
+            if data.get("rt_cd") == "0":
+                return data
+            else:
+                logging.warning(
+                    f"KIS API 조회 실패 ({tr_id} / {params.get('fid_input_iscd')}): {data.get('msg1')}"
+                )
+    except Exception as e:
+        logging.error(f"❌ KIS API 요청 오류 ({tr_id}): {e}")
+    return None
+
+
+# --- 데이터 소스별 조회 함수 ---
+
+
+def load_or_create_corp_code_list():
+    filename = _get_cache_path("corp_codes", "corp_code_list.parquet")
+    if _is_cache_valid(filename, duration_days=1):
+        cached_df = _load_data_from_cache(filename)
+        if cached_df is not None:
+            return cached_df
+    try:
+        dart_url = f"https://opendart.fss.or.kr/api/corpCode.xml?crtfc_key={API_KEY}"
+        res = requests.get(dart_url)
+        res.raise_for_status()
+        with zipfile.ZipFile(io.BytesIO(res.content)) as z, z.open("CORPCODE.xml") as f:
+            tree = parse(f)
+        root = tree.getroot()
+        data = [
+            (
+                c.find("corp_code").text,
+                c.find("corp_name").text,
+                c.find("stock_code").text.strip(),
+            )
+            for c in root.findall("list")
+            if c.find("stock_code").text.strip()
+        ]
+        dart_df = pd.DataFrame(data, columns=["corp_code", "corp_name", "stock_code"])
+        dart_df["stock_code"] = dart_df["stock_code"].str.zfill(6)
+
+        otp_url = "http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd"
+        otp_form = {
+            "mktId": "ALL",
+            "trdDd": pd.Timestamp.today().strftime("%Y%m%d"),
+            "url": "dbms/MDC/STAT/standard/MDCSTAT01901",
+        }
+        otp_res = requests.post(
+            otp_url, data=otp_form, headers={"User-Agent": "Mozilla/5.0"}
+        )
+        otp_res.raise_for_status()
+
+        download_url = "http://data.krx.co.kr/comm/fileDn/download_csv/download.cmd"
+        krx_res = requests.post(
+            download_url,
+            data={"code": otp_res.text},
+            headers={"User-Agent": "Mozilla/5.0"},
+        )
+        krx_res.raise_for_status()
+
+        krx_df = pd.read_csv(io.BytesIO(krx_res.content), encoding="euc-kr")
+        code_col = next(
+            (col for col in ["종목코드", "단축코드"] if col in krx_df.columns), None
+        )
+        if not code_col:
+            raise KeyError("KRX 데이터에서 종목코드 컬럼을 찾을 수 없습니다.")
+
+        krx_df.rename(
+            columns={
+                code_col: "stock_code",
+                "기업명": "corp_name_krx",
+                "시장구분": "market",
+            },
+            inplace=True,
+        )
+        krx_df["stock_code"] = krx_df["stock_code"].astype(str).str.zfill(6)
+
+        merged_df = pd.merge(
+            dart_df, krx_df[["stock_code", "market"]], on="stock_code", how="inner"
+        )
+        _save_data_to_cache(merged_df, filename)
+        return merged_df
+    except Exception as e:
+        logging.error(f"❌ 최신 상장사 목록 불러오기 실패: {e}", exc_info=True)
+        return pd.DataFrame()
+
+
+async def get_financial_statement_async(
+    session, corp_code, year, return_report_name=False
+):
+    report_configs = [
+        ("11011", "사업보고서"),
+        ("11014", "3분기보고서"),
+        ("11012", "반기보고서"),
+        ("11013", "1분기보고서"),
+    ]
+    fs_configs = [("CFS", "연결"), ("OFS", "별도")]
+    for rp_code, rp_name in report_configs:
+        for fs_div, fs_name in fs_configs:
+            cache_file = _get_cache_path(
+                "financials", corp_code, f"async_{year}_{rp_code}_{fs_div}.parquet"
+            )
+            if _is_cache_valid(cache_file, duration_days=7):
+                df = _load_data_from_cache(cache_file)
+                if df is not None:
+                    result = (
+                        corp_code,
+                        {"status": "000", "list": df.to_dict(orient="records")},
+                    )
+                    return (
+                        (*result, f"{rp_name} - {fs_name}")
+                        if return_report_name
+                        else result
+                    )
+            url = "https://opendart.fss.or.kr/api/fnlttSinglAcntAll.json"
+            params = {
+                "crtfc_key": API_KEY,
+                "corp_code": corp_code,
+                "bsns_year": str(year),
+                "reprt_code": rp_code,
+                "fs_div": fs_div,
+            }
+            try:
+                await asyncio.sleep(0.1)
+                async with session.get(url, params=params, timeout=10) as resp:
+                    resp.raise_for_status()
+                    data = await resp.json()
+                    if data.get("status") == "000" and data.get("list"):
+                        df = pd.DataFrame(data["list"])
+                        _save_data_to_cache(df, cache_file)
+                        result = (corp_code, data)
+                        return (
+                            (*result, f"{rp_name} - {fs_name}")
+                            if return_report_name
+                            else result
+                        )
+            except Exception as e:
+                logging.error(f"DART API 오류 ({corp_code}, {year}, {rp_name}): {e}")
+                error_result = (corp_code, {"status": "999", "message": str(e)}, None)
+                return error_result if return_report_name else error_result[:2]
+
+    logging.warning(f"❌ {corp_code}의 {year}년 재무제표를 찾을 수 없습니다.")
+    final_result = (corp_code, {"status": "013", "message": "데이터 없음"})
+    return (*final_result, "N/A") if return_report_name else final_result
+
+
+async def get_kis_daily_price_async(session, stock_code, start_date, end_date):
+    start_dt, end_dt = pd.to_datetime(start_date), pd.to_datetime(end_date)
+    cache_file = _get_cache_path(
+        "prices",
+        stock_code,
+        f'kis_{start_dt.strftime("%Y%m%d")}_{end_dt.strftime("%Y%m%d")}.parquet',
+    )
+    if _is_cache_valid(cache_file, duration_days=1):
+        df = _load_data_from_cache(cache_file)
+        if df is not None:
+            return stock_code, df
+
+    url = f"{KIS_BASE_URL}/uapi/domestic-stock/v1/quotations/inquire-daily-price"
+    params = {
+        "FID_COND_MRKT_DIV_CODE": "J",
+        "FID_INPUT_ISCD": stock_code,
+        "FID_INPUT_DATE_1": start_dt.strftime("%Y%m%d"),
+        "FID_INPUT_DATE_2": end_dt.strftime("%Y%m%d"),
+        "FID_PERIOD_DIV_CODE": "D",
+        "FID_ORG_ADJ_PRC": "1",
+    }
+    data = await _fetch_kis_data(session, url, "FHKST01010400", params)
+
+    if data and data.get("output"):
+        df = pd.DataFrame(data["output"])
+        df.rename(
+            columns={
+                "stck_bsop_date": "date",
+                "stck_oprc": "open",
+                "stck_hgpr": "high",
+                "stck_lwpr": "low",
+                "stck_clpr": "close",
+                "acml_vol": "volume",
+                "acml_tr_pbmn": "transaction_amount",
+                "prdy_vrss": "change",
+            },
+            inplace=True,
+        )
+        final_cols = [
+            col
+            for col in [
+                "date",
+                "open",
+                "high",
+                "low",
+                "close",
+                "volume",
+                "transaction_amount",
+                "change",
+            ]
+            if col in df.columns
+        ]
+        for col in final_cols:
+            if col != "date":
+                df[col] = pd.to_numeric(df[col], errors="coerce")
+        df["date"] = pd.to_datetime(df["date"], format="%Y%m%d")
+        df = df[final_cols].sort_values("date").reset_index(drop=True)
+        _save_data_to_cache(df, cache_file)
+        return stock_code, df
+
+    return stock_code, pd.DataFrame()
+
+
+# [신규] KIS API 상세 재무비율 조회
+async def get_kis_financial_ratios_async(session, stock_code: str):
+    cache_file = _get_cache_path("kis_ratios", f"{stock_code}.parquet")
+    if _is_cache_valid(cache_file, duration_days=7):
+        df = _load_data_from_cache(cache_file)
+        if df is not None:
+            return df
+
+    url = f"{KIS_BASE_URL}/uapi/domestic-stock/v1/finance/financial-ratio"
+    params = {
+        "fid_div_cls_code": "0",  # 0:연간, 1:분기 (필수)
+        "fid_cond_mrkt_div_code": "J",
+        "fid_input_iscd": stock_code,
+    }
+    data = await _fetch_kis_data(session, url, "FHKST66430300", params)
+    if data and data.get("output"):
+        df = pd.DataFrame(data["output"])
+        cols = {
+            "stac_yymm": "결산년월",
+            "grs_rt": "매출총이익률",
+            "bsop_prfi_inrt": "영업이익률",
+            "thtr_ntin_inrt": "당기순이익률",
+            "roe_val": "ROE",
+            "eps": "EPS",
+            "bps": "BPS",
+            "pbr": "PBR",
+            "dvd_yd_rt": "배당수익률",
+        }
+        df = df[[key for key in cols.keys() if key in df.columns]].rename(columns=cols)
+        for col in df.columns:
+            if col != "결산년월":
+                df[col] = pd.to_numeric(df[col], errors="coerce")
+        _save_data_to_cache(df, cache_file)
+        return df
+    return pd.DataFrame()
+
+
+# [신규] KIS API 투자의견 조회
+async def get_kis_investment_opinion_async(session, stock_code: str):
+    cache_file = _get_cache_path("kis_opinion", f"{stock_code}.json")
+    if _is_cache_valid(cache_file, duration_days=1):
+        data = _load_data_from_cache(cache_file)
+        if data:
+            return data
+
+    # ✅ 문서 기준 최신 경로 / TR_ID 사용
+    url = f"{KIS_BASE_URL}/uapi/domestic-stock/v1/quotations/invest-opinion"
+    params = {
+        "FID_COND_MRKT_DIV_CODE": "J",  # 시장구분
+        "FID_COND_SCR_DIV_CODE": "16633",  # 고정값(문서 PK)
+        "FID_INPUT_ISCD": stock_code,
+        "FID_INPUT_DATE_1": (datetime.today() - timedelta(days=365)).strftime("%Y%m%d"),
+        "FID_INPUT_DATE_2": datetime.today().strftime("%Y%m%d"),
+    }
+    data = await _fetch_kis_data(session, url, "FHKST663300C0", params)
+
+    if data and data.get("output"):
+        output = data["output"][0]
+
+        opinion_data = {
+            "opinion": output.get("invt_opnn"),  # ex) 매수, 중립
+            "target_price": float(output.get("hts_goal_prc") or 0),  # numpy → float
+            "analyst_count": int(output.get("nm_of_analyst") or 0),  # 빈 값 → 0
+        }
+        _save_data_to_cache(opinion_data, cache_file)
+        return opinion_data
+    return {}
+
+
+# --- 여러 기업 데이터 동시 조회 ---
+async def fetch_multiple_financials(corp_codes, year):
+    async with aiohttp.ClientSession() as session:
+        tasks = [
+            get_financial_statement_async(session, code, year) for code in corp_codes
+        ]
+        results = await asyncio.gather(*tasks)
+        return {code: data for code, data in results}
+
+
+async def fetch_multiple_prices(stock_codes, start_date, end_date):
+    async with aiohttp.ClientSession() as session:
+        tasks = [
+            get_kis_daily_price_async(session, code, start_date, end_date)
+            for code in stock_codes
+        ]
+        results = await asyncio.gather(*tasks)
+        return {code: df for code, df in results if df is not None}
diff --git a/packages/core/build/lib/core/_legacy_report_generator.py b/packages/core/build/lib/core/_legacy_report_generator.py
new file mode 100644
index 0000000..fbc6ce5
--- /dev/null
+++ b/packages/core/build/lib/core/_legacy_report_generator.py
@@ -0,0 +1,479 @@
+import os
+import requests
+import tempfile
+import pandas as pd
+import numpy as np  # np.nan 사용을 위해 추가
+from fpdf import FPDF
+import plotly.express as px
+import plotly.graph_objects as go
+import logging
+from io import BytesIO
+from dotenv import load_dotenv  # API_KEY 로드를 위해 추가 (독립 실행시)
+
+# src 폴더 내 모듈 임포트
+from ._legacy_analysis import extract_fs_summary
+from ._legacy_data_fetch import (
+    load_or_create_corp_code_list,
+    get_fiscal_month,
+)  # get_fiscal_month는 현재 사용되지 않지만, 혹시 모를 미래 확장을 위해 유지
+
+# 로깅 설정 (다른 모듈과 일관성 유지)
+logging.basicConfig(
+    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
+)
+
+# 환경변수 로드 (이 모듈이 독립적으로 실행될 경우를 대비)
+load_dotenv()
+API_KEY = os.getenv("API_KEY")
+if not API_KEY:
+    logging.warning(
+        "API_KEY가 설정되지 않았습니다. .env 파일을 확인하거나 data_fetch 모듈이 먼저 실행되었는지 확인하세요."
+    )
+
+# 리포트 저장 경로 생성
+os.makedirs("data/reports", exist_ok=True)
+os.makedirs("data/fonts", exist_ok=True)  # 폰트 폴더 생성
+
+
+# ---------------------------------------------------
+# PDF 생성 클래스 확장
+# ---------------------------------------------------
+class PDFReport(FPDF):
+    def __init__(self, orientation="P", unit="mm", format="A4"):
+        super().__init__(orientation, unit, format)
+        self.set_auto_page_break(auto=True, margin=15)
+        self.add_korean_font()  # 한글 폰트 추가
+        self.set_font("CustomFont", "", 12)  # 기본 폰트 설정
+
+    def add_korean_font(self):
+        """
+        한글 폰트(NotoSansKR-Regular.ttf)를 로드합니다.
+        폰트 파일이 없으면 Arial로 대체됩니다.
+        """
+        # 폰트 파일 경로: 프로젝트 루트의 fonts/ 디렉토리
+        font_path = os.path.join(
+            os.path.dirname(os.path.abspath(__file__)),
+            "..",
+            "fonts",
+            "NotoSansKR-Regular.ttf",
+        )
+        font_path = os.path.normpath(font_path)  # 경로 정규화
+
+        if os.path.exists(font_path):
+            try:
+                self.add_font("CustomFont", "", font_path, uni=True)
+                logging.info(f"✅ 한글 폰트 로드 성공: {font_path}")
+            except Exception as e:
+                logging.error(
+                    f"❌ 한글 폰트 로드 실패 ({font_path}): {e}. Arial로 대체됩니다.",
+                    exc_info=True,
+                )
+                self.set_font("Arial", "", 12)
+        else:
+            logging.warning(
+                f"❌ 한글 폰트 파일이 없습니다: {font_path}. Arial로 대체됩니다. fonts/NotoSansKR-Regular.ttf를 추가해주세요."
+            )
+            self.set_font("Arial", "", 12)  # 폰트 파일이 없으면 Arial로 대체
+
+    def header(self):
+        self.set_font("CustomFont", "B", 16)
+        self.cell(0, 10, self.safe_text("기업 재무 분석 보고서"), ln=True, align="C")
+        self.ln(5)
+
+    def footer(self):
+        self.set_y(-15)
+        self.set_font("CustomFont", "I", 8)
+        self.cell(0, 10, self.safe_text(f"페이지 {self.page_no()}/{{nb}}"), 0, 0, "C")
+
+    def chapter_title(self, title):
+        self.set_font("CustomFont", "B", 12)
+        self.cell(0, 10, self.safe_text(title), ln=True)
+        self.ln(2)
+
+    def chapter_body(self, body):
+        self.set_font("CustomFont", "", 10)
+        self.multi_cell(0, 7, self.safe_text(body))
+        self.ln()
+
+    def add_image_from_bytes(self, img_bytes, w=180, h=0, x=None, y=None):
+        """BytesIO 객체에서 이미지를 추가합니다."""
+        try:
+            self.image(img_bytes, x=x, y=y, w=w, h=h, type="PNG")
+            self.ln(5)
+        except Exception as e:
+            logging.error(f"이미지 추가 중 오류 발생: {e}", exc_info=True)
+
+    def safe_text(self, text):
+        """FPDF 폰트가 지원하지 않는 문자를 제거합니다."""
+        if self.font_family == "Arial":  # Arial 폰트 사용 시 이모티콘 등 제거
+            return "".join(ch for ch in text if ord(ch) <= 0xFFFF)
+        return text  # CustomFont는 유니코드 지원하므로 그대로 반환
+
+
+# ---------------------------------------------------
+# 헬퍼 함수: 기업 코드 정보 조회
+# ---------------------------------------------------
+def _get_corp_codes_info(corp_name: str) -> tuple[str, str]:
+    """
+    기업명으로 corp_code와 stock_code를 조회합니다.
+    """
+    corp_codes_df = load_or_create_corp_code_list()
+    row = corp_codes_df[corp_codes_df["corp_name"] == corp_name]
+    if row.empty:
+        logging.error(f"기업명 '{corp_name}'에 해당하는 기업 코드를 찾을 수 없습니다.")
+        raise ValueError(f"기업명 '{corp_name}'을(를) 찾을 수 없습니다.")
+
+    row = row.iloc[0]
+    corp_code = row["corp_code"]
+    stock_code = (
+        str(row["stock_code"]).zfill(6) if pd.notna(row["stock_code"]) else None
+    )
+    return corp_code, stock_code
+
+
+# ---------------------------------------------------
+# 헬퍼 함수: 기업 개요 및 로고 조회
+# ---------------------------------------------------
+def _fetch_company_overview_safe(corp_code: str) -> dict:
+    """DART API에서 기업 개요를 안전하게 가져옵니다."""
+    url = "https://opendart.fss.or.kr/api/company.json"
+    params = {"crtfc_key": API_KEY, "corp_code": corp_code}
+    try:
+        res = requests.get(url, params=params, timeout=5)
+        res.raise_for_status()  # HTTP 에러 발생 시 예외 발생
+        data = res.json()
+        if data.get("status") == "000":
+            logging.info(f"✅ 기업 개요 조회 성공: {corp_code}")
+            return {
+                "기업명": data.get("corp_name"),
+                "영문명": data.get("corp_name_eng"),
+                "업종": data.get("industry"),
+                "설립일": data.get("est_dt"),
+                "대표자": data.get("ceo_nm"),
+                "홈페이지": data.get("hm_url"),
+                "주소": data.get("adres"),
+            }
+        else:
+            logging.warning(
+                f"DART 기업 개요 조회 실패 ({corp_code}): {data.get('message', '알 수 없는 오류')}"
+            )
+            return {}
+    except requests.exceptions.RequestException as e:
+        logging.error(f"DART 기업 개요 API 요청 오류 ({corp_code}): {e}", exc_info=True)
+        return {}
+    except Exception as e:
+        logging.error(
+            f"기업 개요 처리 중 예상치 못한 오류 발생 ({corp_code}): {e}", exc_info=True
+        )
+        return {}
+
+
+def _fetch_company_logo_safe(stock_code: str) -> BytesIO | None:
+    """네이버 금융에서 기업 로고를 안전하게 가져옵니다."""
+    if not stock_code:
+        return None
+    try:
+        logo_url = (
+            f"https://ssl.pstatic.net/imgfinance/chart/item/200x200/{stock_code}.png"
+        )
+        res = requests.get(logo_url, timeout=5)
+        res.raise_for_status()
+        if res.status_code == 200 and res.content:
+            logging.info(f"✅ 기업 로고 조회 성공: {stock_code}")
+            return BytesIO(res.content)
+        else:
+            logging.warning(
+                f"기업 로고를 찾을 수 없거나 응답이 비어있습니다: {stock_code}"
+            )
+            return None
+    except requests.exceptions.RequestException as e:
+        logging.warning(f"기업 로고 다운로드 실패 ({stock_code}): {e}")
+        return None
+    except Exception as e:
+        logging.error(
+            f"기업 로고 처리 중 예상치 못한 오류 발생 ({stock_code}): {e}",
+            exc_info=True,
+        )
+        return None
+
+
+# ---------------------------------------------------
+# 헬퍼 함수: Plotly 차트 생성
+# ---------------------------------------------------
+def _create_price_chart(price_df: pd.DataFrame, corp_name: str) -> BytesIO | None:
+    """
+    주가 추이 차트를 생성하고 BytesIO 객체로 반환합니다.
+    """
+    if (
+        price_df.empty
+        or "date" not in price_df.columns
+        or "close" not in price_df.columns
+    ):
+        logging.warning(
+            f"주가 데이터가 불완전하여 주가 차트를 생성할 수 없습니다: {corp_name}"
+        )
+        return None
+
+    # price_df의 컬럼명을 영문화 (data_fetch에서 이미 처리되지만, 안전을 위해 다시 확인)
+    if "날짜" in price_df.columns:
+        price_df.rename(
+            columns={
+                "날짜": "date",
+                "종가": "close",
+                "전일비": "diff",
+                "시가": "open",
+                "고가": "high",
+                "저가": "low",
+                "거래량": "volume",
+            },
+            inplace=True,
+        )
+
+    fig_price = px.line(
+        price_df,
+        x="date",
+        y="close",
+        title=f"{corp_name} 주가 추이",
+        labels={"date": "날짜", "close": "종가"},
+        template="plotly_white",  # 깔끔한 배경
+    )
+    fig_price.update_layout(title_x=0.5)  # 제목 중앙 정렬
+    try:
+        img_bytes = BytesIO()
+        fig_price.write_image(img_bytes, format="png", scale=2)  # 고해상도 PNG
+        img_bytes.seek(0)
+        logging.info(f"✅ 주가 차트 생성 성공: {corp_name}")
+        return img_bytes
+    except Exception as e:
+        logging.error(f"주가 차트 이미지 생성 실패 ({corp_name}): {e}", exc_info=True)
+        return None
+
+
+def _create_ratio_chart(health: dict, corp_name: str, year: int) -> BytesIO | None:
+    """
+    주요 재무비율 차트를 생성하고 BytesIO 객체로 반환합니다.
+    """
+    if not health or all(pd.isna(v) for v in health.values()):
+        logging.warning(
+            f"재무 건전성 데이터가 없어 재무비율 차트를 생성할 수 없습니다: {corp_name}"
+        )
+        return None
+
+    # 차트 데이터 준비
+    ratio_names = [
+        "ROE",
+        "부채비율",
+        "유동비율",
+        "영업이익률",
+        "이자보상배율",
+        "Z-score",
+    ]
+    ratio_values = [
+        health.get("roe", np.nan),
+        health.get("debt_ratio", np.nan),
+        health.get("current_ratio", np.nan),
+        health.get("op_margin", np.nan),
+        health.get("interest_coverage", np.nan),
+        health.get("z_score", np.nan),
+    ]
+
+    # NaN 값은 차트에 표시되지 않도록 필터링
+    filtered_ratios = [
+        (name, value)
+        for name, value in zip(ratio_names, ratio_values)
+        if not pd.isna(value)
+    ]
+    if not filtered_ratios:
+        logging.warning(
+            f"유효한 재무비율 데이터가 없어 재무비율 차트를 생성할 수 없습니다: {corp_name}"
+        )
+        return None
+
+    chart_df = pd.DataFrame(filtered_ratios, columns=["Ratio", "Value"])
+
+    fig_ratio = px.bar(
+        chart_df,
+        x="Ratio",
+        y="Value",
+        title=f"{corp_name} 주요 재무비율 ({year})",
+        labels={"Ratio": "재무비율", "Value": "값"},
+        template="plotly_white",
+        color_discrete_sequence=px.colors.qualitative.Pastel,  # 색상 팔레트 변경
+    )
+    fig_ratio.update_layout(title_x=0.5)
+    try:
+        img_bytes = BytesIO()
+        fig_ratio.write_image(img_bytes, format="png", scale=2)
+        img_bytes.seek(0)
+        logging.info(f"✅ 재무비율 차트 생성 성공: {corp_name}")
+        return img_bytes
+    except Exception as e:
+        logging.error(
+            f"재무비율 차트 이미지 생성 실패 ({corp_name}): {e}", exc_info=True
+        )
+        return None
+
+
+# ---------------------------------------------------
+# Excel 보고서 저장 (기존 기능 유지)
+# ---------------------------------------------------
+def save_excel_report(
+    df_results: pd.DataFrame,
+    df_industry_avg: pd.DataFrame,
+    filename: str = "financial_report.xlsx",
+) -> str:
+    """
+    분석 결과를 Excel 파일로 저장합니다.
+    """
+    file_path = os.path.join("data/reports", filename)
+    try:
+        with pd.ExcelWriter(file_path, engine="xlsxwriter") as writer:
+            df_results.to_excel(writer, sheet_name="기업별 분석", index=False)
+            df_industry_avg.to_excel(writer, sheet_name="업종별 평균")
+        logging.info(f"✅ Excel 보고서 저장 완료: {file_path}")
+        return file_path
+    except Exception as e:
+        logging.error(f"❌ Excel 보고서 저장 실패 ({file_path}): {e}", exc_info=True)
+        return ""
+
+
+# ---------------------------------------------------
+# 통합 투자 리포트 생성 (PDF)
+# ---------------------------------------------------
+def generate_investment_report(
+    corp_name: str, year: int, health: dict, fs_df: pd.DataFrame, price_df: pd.DataFrame
+) -> BytesIO | None:
+    """
+    증권사 리서치센터 스타일의 통합 투자 리포트(PDF)를 생성합니다.
+
+    Args:
+        corp_name (str): 기업명.
+        year (int): 분석 연도.
+        health (dict): calculate_financial_health 함수에서 반환된 재무 건전성 지표.
+        fs_df (pd.DataFrame): 재무제표 데이터 DataFrame.
+        price_df (pd.DataFrame): 주가 데이터 DataFrame.
+
+    Returns:
+        BytesIO | None: 생성된 PDF 파일의 BytesIO 객체. 실패 시 None.
+    """
+    try:
+        # 1. 기업 코드 및 주식 코드 조회
+        corp_code, stock_code = _get_corp_codes_info(corp_name)
+        if not corp_code:
+            return None
+
+        # 2. 기업 개요 및 로고 조회
+        overview = _fetch_company_overview_safe(corp_code)
+        logo_img_bytes = _fetch_company_logo_safe(stock_code)
+
+        # 3. 재무제표 요약
+        fs_summary = extract_fs_summary(fs_df)
+
+        # 4. 차트 생성 (BytesIO로 직접 받음)
+        price_chart_bytes = _create_price_chart(price_df, corp_name)
+        ratio_chart_bytes = _create_ratio_chart(health, corp_name, year)
+
+        # 5. PDF 생성 시작
+        pdf = PDFReport()
+        pdf.add_page()
+        pdf.set_left_margin(20)
+        pdf.set_right_margin(20)
+
+        # 제목 섹션
+        pdf.set_font("CustomFont", "B", 24)
+        pdf.cell(
+            0, 15, pdf.safe_text(f"{corp_name} {year} 투자 리포트"), ln=True, align="C"
+        )
+        pdf.ln(5)
+
+        # 로고 추가 (있다면)
+        if logo_img_bytes:
+            # 로고를 오른쪽 상단에 배치
+            pdf.image(logo_img_bytes, x=pdf.w - 40, y=10, w=30)
+            logo_img_bytes.seek(0)  # 재사용을 위해 포인터 초기화
+
+        # 구분선
+        pdf.set_draw_color(0, 0, 0)
+        pdf.set_line_width(0.5)
+        pdf.line(20, pdf.get_y(), pdf.w - 20, pdf.get_y())
+        pdf.ln(10)
+
+        # 종합 점수 및 등급
+        pdf.set_font("CustomFont", "", 14)
+        total_score_str = (
+            f"{health['total_score']:.2f}"
+            if not pd.isna(health.get("total_score"))
+            else "N/A"
+        )
+        grade_str = health.get("grade", "N/A")
+        pdf.cell(
+            0,
+            10,
+            pdf.safe_text(f"✨ 종합 점수: {total_score_str} | 등급: {grade_str}"),
+            ln=True,
+        )
+        pdf.ln(5)
+
+        # 기업 개요
+        if overview:
+            pdf.set_font("CustomFont", "B", 14)
+            pdf.cell(0, 10, pdf.safe_text("📄 기업 개요"), ln=True)
+            pdf.set_font("CustomFont", "", 11)
+            for k, v in overview.items():
+                if v:
+                    pdf.cell(0, 7, pdf.safe_text(f"{k}: {v}"), ln=True)
+            pdf.ln(5)
+
+        # 재무제표 요약
+        if fs_summary:
+            pdf.set_font("CustomFont", "B", 14)
+            pdf.cell(0, 10, pdf.safe_text("📊 재무제표 요약"), ln=True)
+            pdf.set_font("CustomFont", "", 11)
+            for k, v in fs_summary.items():
+                if not pd.isna(v):
+                    pdf.cell(
+                        0, 7, pdf.safe_text(f"{k}: {v:,.0f} 원"), ln=True
+                    )  # 천단위 콤마, 원 표시
+            pdf.ln(5)
+
+        # 재무비율 차트
+        if ratio_chart_bytes:
+            pdf.add_page()  # 새 페이지에 차트 추가
+            pdf.set_font("CustomFont", "B", 14)
+            pdf.cell(0, 10, pdf.safe_text("📈 주요 재무비율 분석"), ln=True)
+            pdf.ln(5)
+            pdf.add_image_from_bytes(ratio_chart_bytes, w=180)
+            ratio_chart_bytes.seek(0)  # 재사용을 위해 포인터 초기화
+            pdf.ln(5)
+
+        # 주가 차트
+        if price_chart_bytes:
+            if (
+                pdf.get_y() > pdf.h - 80
+            ):  # 현재 페이지 하단에 공간이 부족하면 새 페이지 시작
+                pdf.add_page()
+            pdf.set_font("CustomFont", "B", 14)
+            pdf.cell(0, 10, pdf.safe_text("💹 주가 추이 분석"), ln=True)
+            pdf.ln(5)
+            pdf.add_image_from_bytes(price_chart_bytes, w=180)
+            price_chart_bytes.seek(0)  # 재사용을 위해 포인터 초기화
+            pdf.ln(5)
+
+        # PDF를 BytesIO 객체로 저장
+        pdf_output = BytesIO()
+        pdf.output(pdf_output)
+        pdf_output.seek(0)  # 스트림의 시작으로 포인터 이동
+
+        logging.info(f"✅ '{corp_name}' {year} 투자 리포트 PDF 생성 완료.")
+        return pdf_output
+
+    except ValueError as e:
+        logging.error(f"리포트 생성 오류 (데이터 문제): {e}")
+        return None
+    except Exception as e:
+        logging.error(f"리포트 생성 중 예상치 못한 오류 발생: {e}", exc_info=True)
+        return None
+
+
+# 기존 generate_investment_report_full 및 create_visual_pdf는 제거됨
+# generate_investment_report 함수가 모든 기능을 통합함.
diff --git a/packages/core/build/lib/core/_legacy_visualization.py b/packages/core/build/lib/core/_legacy_visualization.py
new file mode 100644
index 0000000..fefb0d0
--- /dev/null
+++ b/packages/core/build/lib/core/_legacy_visualization.py
@@ -0,0 +1,376 @@
+import plotly.express as px
+import plotly.graph_objects as go
+import pandas as pd
+import numpy as np
+import logging
+
+# 로깅 설정 (다른 모듈과 일관성 유지)
+logging.basicConfig(
+    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
+)
+
+
+# ---------------------------------------------------
+# 헬퍼 함수: 공통 레이아웃 업데이트
+# ---------------------------------------------------
+def _update_common_layout(fig: go.Figure, title: str, dark_mode: bool = False):
+    """
+    Plotly 차트의 공통 레이아웃을 업데이트합니다.
+    Args:
+        fig (go.Figure): Plotly Figure 객체.
+        title (str): 차트 제목.
+        dark_mode (bool): 다크 모드 적용 여부.
+    """
+    template = "plotly_dark" if dark_mode else "plotly_white"
+    fig.update_layout(
+        title_text=title,
+        title_x=0.5,  # 제목 중앙 정렬
+        template=template,
+        hovermode="x unified",  # 마우스 오버 시 정보 표시 방식
+        font=dict(
+            family="Arial, sans-serif", size=12, color="white" if dark_mode else "black"
+        ),
+        paper_bgcolor=(
+            "rgba(0,0,0,0)" if dark_mode else "rgba(0,0,0,0)"
+        ),  # 배경 투명하게
+        plot_bgcolor=(
+            "rgba(0,0,0,0)" if dark_mode else "rgba(0,0,0,0)"
+        ),  # 플롯 영역 배경 투명하게
+    )
+    # 축 색상 설정
+    fig.update_xaxes(
+        showgrid=True,
+        gridwidth=1,
+        gridcolor="rgba(150,150,150,0.2)" if dark_mode else "rgba(200,200,200,0.5)",
+        zeroline=False,
+        linecolor="rgba(150,150,150,0.5)" if dark_mode else "rgba(100,100,100,0.5)",
+        tickfont=dict(color="white" if dark_mode else "black"),
+        title_font=dict(color="white" if dark_mode else "black"),
+    )
+    fig.update_yaxes(
+        showgrid=True,
+        gridwidth=1,
+        gridcolor="rgba(150,150,150,0.2)" if dark_mode else "rgba(200,200,200,0.5)",
+        zeroline=False,
+        linecolor="rgba(150,150,150,0.5)" if dark_mode else "rgba(100,100,100,0.5)",
+        tickfont=dict(color="white" if dark_mode else "black"),
+        title_font=dict(color="white" if dark_mode else "black"),
+    )
+
+
+# ---------------------------------------------------
+# 재무 비율 막대그래프
+# ---------------------------------------------------
+def plot_ratios(
+    health_dict: dict, title: str = "주요 재무 비율", dark_mode: bool = False
+) -> go.Figure:
+    """
+    재무 건전성 지표를 막대그래프로 시각화합니다.
+    Args:
+        health_dict (dict): 재무 건전성 지표 딕셔너리 (calculate_financial_health 결과).
+        title (str): 차트 제목.
+        dark_mode (bool): 다크 모드 적용 여부.
+    Returns:
+        go.Figure: Plotly Figure 객체.
+    """
+    if not health_dict or all(pd.isna(v) for v in health_dict.values()):
+        logging.warning(
+            "재무 건전성 데이터가 비어있어 재무 비율 차트를 생성할 수 없습니다."
+        )
+        fig = go.Figure()
+        _update_common_layout(fig, f"{title} (데이터 없음)", dark_mode)
+        return fig
+
+    # total_score와 grade 제외
+    df_ratios = pd.DataFrame(health_dict.items(), columns=["지표", "값"])
+    df_ratios = df_ratios[~df_ratios["지표"].isin(["total_score", "grade"])]
+
+    # NaN 값 제거 (차트에 표시되지 않도록)
+    df_ratios = df_ratios.dropna(subset=["값"])
+
+    if df_ratios.empty:
+        logging.warning("유효한 재무 비율 데이터가 없어 차트를 생성할 수 없습니다.")
+        fig = go.Figure()
+        _update_common_layout(fig, f"{title} (데이터 없음)", dark_mode)
+        return fig
+
+    fig = px.bar(
+        df_ratios,
+        x="지표",
+        y="값",
+        text="값",
+        color="지표",
+        color_discrete_sequence=px.colors.qualitative.Pastel,  # 부드러운 색상 팔레트
+    )
+    fig.update_traces(
+        texttemplate="%{text:.2f}",
+        textposition="outside",
+        marker_line_color="rgb(8,48,107)",
+        marker_line_width=1.5,
+        opacity=0.8,
+    )
+    fig.update_layout(yaxis_title="값", xaxis_title="지표", showlegend=False)
+
+    _update_common_layout(fig, title, dark_mode)
+    logging.info(f"✅ 재무 비율 차트 생성 완료: {title}")
+    return fig
+
+
+# ---------------------------------------------------
+# 주가 데이터 시각화 (라인 차트 또는 캔들스틱 차트)
+# ---------------------------------------------------
+def plot_price(
+    price_df: pd.DataFrame,
+    corp_name: str,
+    chart_type: str = "line",
+    dark_mode: bool = False,
+) -> go.Figure:
+    """
+    주가 데이터를 라인 차트 또는 캔들스틱 차트로 시각화합니다.
+    Args:
+        price_df (pd.DataFrame): 주가 데이터 DataFrame (date, open, high, low, close, volume 컬럼 포함).
+        corp_name (str): 기업명.
+        chart_type (str): "line" (라인 차트) 또는 "candlestick" (캔들스틱 차트). 기본값 "line".
+        dark_mode (bool): 다크 모드 적용 여부.
+    Returns:
+        go.Figure: Plotly Figure 객체.
+    """
+    if price_df.empty or "date" not in price_df.columns:
+        logging.warning(
+            f"{corp_name} 주가 데이터가 비어있거나 'date' 컬럼이 없어 차트를 생성할 수 없습니다."
+        )
+        fig = go.Figure()
+        _update_common_layout(fig, f"{corp_name} 주가 추이 (데이터 없음)", dark_mode)
+        return fig
+
+    # 컬럼명 영문화 (data_fetch에서 이미 처리되지만, 안전을 위해 다시 확인)
+    if "날짜" in price_df.columns:
+        price_df.rename(
+            columns={
+                "날짜": "date",
+                "종가": "close",
+                "전일비": "diff",
+                "시가": "open",
+                "고가": "high",
+                "저가": "low",
+                "거래량": "volume",
+            },
+            inplace=True,
+        )
+
+    # 'date' 컬럼을 datetime으로 변환
+    price_df["date"] = pd.to_datetime(price_df["date"])
+    price_df = price_df.sort_values("date")  # 날짜 오름차순 정렬
+
+    fig = go.Figure()
+    chart_title = f"{corp_name} 주가 추이"
+
+    if chart_type == "candlestick":
+        # 캔들스틱 차트 생성에 필요한 컬럼 확인
+        required_cols = ["open", "high", "low", "close"]
+        if not all(col in price_df.columns for col in required_cols):
+            logging.warning(
+                f"캔들스틱 차트 생성에 필요한 컬럼({required_cols})이 부족합니다. 라인 차트로 대체합니다."
+            )
+            chart_type = "line"  # 필요한 컬럼이 없으면 라인 차트로 대체
+
+        if chart_type == "candlestick":
+            fig.add_trace(
+                go.Candlestick(
+                    x=price_df["date"],
+                    open=price_df["open"],
+                    high=price_df["high"],
+                    low=price_df["low"],
+                    close=price_df["close"],
+                    name="주가",
+                )
+            )
+            chart_title = f"{corp_name} 주가 캔들스틱 차트"
+            fig.update_layout(
+                xaxis_rangeslider_visible=False
+            )  # 캔들스틱 기본 슬라이더 숨김
+
+    if chart_type == "line":
+        fig.add_trace(
+            go.Scatter(
+                x=price_df["date"],
+                y=price_df["close"],
+                mode="lines",
+                name="종가",
+                line=dict(color="royalblue", width=2),
+            )
+        )
+        chart_title = f"{corp_name} 주가 라인 차트"
+
+    # 범위 슬라이더 추가
+    fig.update_layout(
+        xaxis_rangeslider_visible=True,
+        xaxis_rangeselector=dict(
+            buttons=list(
+                [
+                    dict(count=1, label="1m", step="month", stepmode="backward"),
+                    dict(count=6, label="6m", step="month", stepmode="backward"),
+                    dict(count=1, label="1y", step="year", stepmode="backward"),
+                    dict(step="all"),
+                ]
+            )
+        ),
+    )
+
+    _update_common_layout(fig, chart_title, dark_mode)
+    logging.info(f"✅ 주가 차트 생성 완료: {corp_name} ({chart_type})")
+    return fig
+
+
+# ---------------------------------------------------
+# 업종별 평균 지표 막대그래프
+# ---------------------------------------------------
+def plot_industry_avg(
+    industry_avg_df: pd.DataFrame,
+    title: str = "업종별 평균 총점",
+    dark_mode: bool = False,
+) -> go.Figure:
+    """
+    업종별 평균 총점을 막대그래프로 시각화합니다.
+    Args:
+        industry_avg_df (pd.DataFrame): 업종별 평균 데이터 DataFrame.
+        title (str): 차트 제목.
+        dark_mode (bool): 다크 모드 적용 여부.
+    Returns:
+        go.Figure: Plotly Figure 객체.
+    """
+    if (
+        industry_avg_df.empty
+        or "업종" not in industry_avg_df.columns
+        or "total_score" not in industry_avg_df.columns
+    ):
+        logging.warning(
+            "업종별 평균 데이터가 비어있거나 필수 컬럼이 없어 업종 평균 차트를 생성할 수 없습니다."
+        )
+        fig = go.Figure()
+        _update_common_layout(fig, f"{title} (데이터 없음)", dark_mode)
+        return fig
+
+    # '총점' 대신 'total_score' 컬럼 사용 (analysis.py의 calculate_financial_health 결과와 일관성 유지)
+    df = industry_avg_df.reset_index()
+
+    fig = px.bar(
+        df,
+        x="업종",
+        y="total_score",  # '총점' 대신 'total_score' 사용
+        text="total_score",
+        color="업종",
+        color_discrete_sequence=px.colors.qualitative.Set3,
+    )
+    fig.update_traces(
+        texttemplate="%{text:.2f}",
+        textposition="outside",
+        marker_line_color="rgb(8,48,107)",
+        marker_line_width=1.5,
+        opacity=0.8,
+    )
+    fig.update_layout(yaxis_title="총점", xaxis_title="업종", showlegend=False)
+
+    _update_common_layout(fig, title, dark_mode)
+    logging.info(f"✅ 업종별 평균 차트 생성 완료: {title}")
+    return fig
+
+
+# ---------------------------------------------------
+# 개별 기업 vs 업종 평균 지표 비교 막대그래프 (새로 추가)
+# ---------------------------------------------------
+def plot_company_vs_industry_avg(
+    company_data: pd.Series,
+    industry_avg_df: pd.DataFrame,
+    metric_name: str,
+    company_name: str,
+    dark_mode: bool = False,
+) -> go.Figure:
+    """
+    개별 기업의 특정 지표를 해당 기업의 업종 평균과 비교하는 막대그래프를 생성합니다.
+    Args:
+        company_data (pd.Series): 선택된 기업의 분석 결과 (예: multi_results_df의 한 행).
+        industry_avg_df (pd.DataFrame): 업종별 평균 데이터 DataFrame.
+        metric_name (str): 비교할 지표의 이름 (예: '총점', 'ROE', 'PER').
+        company_name (str): 비교할 기업의 이름.
+        dark_mode (bool): 다크 모드 적용 여부.
+    Returns:
+        go.Figure: Plotly Figure 객체.
+    """
+    if (
+        company_data.empty
+        or metric_name not in company_data.index
+        or pd.isna(company_data[metric_name])
+    ):
+        logging.warning(
+            f"기업 '{company_name}'의 '{metric_name}' 데이터가 유효하지 않아 비교 차트를 생성할 수 없습니다."
+        )
+        fig = go.Figure()
+        _update_common_layout(
+            fig,
+            f"'{company_name}' vs 업종 평균 ({metric_name}) (데이터 없음)",
+            dark_mode,
+        )
+        return fig
+
+    company_industry = company_data.get("업종", "알 수 없음")
+
+    # 해당 업종의 평균값 찾기
+    industry_avg_value = np.nan
+    if "업종" in industry_avg_df.columns and metric_name in industry_avg_df.columns:
+        avg_row = industry_avg_df[industry_avg_df["업종"] == company_industry]
+        if not avg_row.empty:
+            industry_avg_value = avg_row.iloc[0][metric_name]
+
+    if pd.isna(industry_avg_value):
+        logging.warning(
+            f"업종 '{company_industry}'의 '{metric_name}' 평균 데이터를 찾을 수 없어 비교 차트를 생성할 수 없습니다."
+        )
+        fig = go.Figure()
+        _update_common_layout(
+            fig,
+            f"'{company_name}' vs 업종 평균 ({metric_name}) (업종 평균 데이터 없음)",
+            dark_mode,
+        )
+        return fig
+
+    # 차트 데이터 생성
+    data = {
+        "Category": [company_name, f"{company_industry} 평균"],
+        "Value": [company_data[metric_name], industry_avg_value],
+    }
+    df_plot = pd.DataFrame(data)
+
+    fig = px.bar(
+        df_plot,
+        x="Category",
+        y="Value",
+        text="Value",
+        title=f"'{company_name}' ({company_industry}) vs 업종 평균: {metric_name}",
+        labels={"Category": "구분", "Value": metric_name},
+        color="Category",
+        color_discrete_map={
+            company_name: px.colors.qualitative.Pastel[0],  # 기업 색상
+            f"{company_industry} 평균": px.colors.qualitative.Pastel[
+                1
+            ],  # 업종 평균 색상
+        },
+    )
+    fig.update_traces(
+        texttemplate="%{text:.2f}",
+        textposition="outside",
+        marker_line_color="rgb(8,48,107)",
+        marker_line_width=1.5,
+        opacity=0.8,
+    )
+    fig.update_layout(showlegend=False)  # 범례 숨기기
+
+    _update_common_layout(
+        fig,
+        f"'{company_name}' ({company_industry}) vs 업종 평균: {metric_name}",
+        dark_mode,
+    )
+    logging.info(
+        f"✅ 기업 vs 업종 평균 비교 차트 생성 완료: {company_name} - {metric_name}"
+    )
+    return fig
diff --git a/packages/core/build/lib/core/clients/__init__.py b/packages/core/build/lib/core/clients/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/packages/core/build/lib/core/clients/dart.py b/packages/core/build/lib/core/clients/dart.py
new file mode 100644
index 0000000..dfec3f5
--- /dev/null
+++ b/packages/core/build/lib/core/clients/dart.py
@@ -0,0 +1,23 @@
+import httpx
+
+
+class DARTClient:
+    def __init__(self, api_key: str, *, timeout: float = 10.0):
+        self._client = httpx.AsyncClient(timeout=timeout)
+        self.api_key = api_key
+
+    async def single_fs(
+        self, corp_code: str, year: int, reprt_code: str, fs_div: str
+    ) -> dict:
+        r = await self._client.get(
+            "https://opendart.fss.or.kr/api/fnlttSinglAcntAll.json",
+            params={
+                "crtfc_key": self.api_key,
+                "corp_code": corp_code,
+                "bsns_year": str(year),
+                "reprt_code": reprt_code,
+                "fs_div": fs_div,
+            },
+        )
+        r.raise_for_status()
+        return r.json()
diff --git a/packages/core/build/lib/core/clients/kis.py b/packages/core/build/lib/core/clients/kis.py
new file mode 100644
index 0000000..79f5e37
--- /dev/null
+++ b/packages/core/build/lib/core/clients/kis.py
@@ -0,0 +1,83 @@
+from __future__ import annotations
+import asyncio
+from datetime import datetime, timedelta
+from typing import Any, Dict, Optional
+import httpx
+
+
+class KISClient:
+    def __init__(
+        self,
+        base_url: str,
+        app_key: str,
+        app_secret: str,
+        *,
+        timeout: float = 10.0,
+        oauth_path: str = "/oauth2/tokenP",
+    ):
+        self.base_url = base_url.rstrip("/")
+        self.app_key = app_key
+        self.app_secret = app_secret
+        self.oauth_path = oauth_path
+        self._client = httpx.AsyncClient(timeout=timeout)
+        self._token: Optional[str] = None
+        self._expires_at: Optional[datetime] = None
+        self._lock = asyncio.Lock()
+
+    async def _ensure_token(self) -> str:
+        async with self._lock:
+            if self._token and self._expires_at and datetime.now() < self._expires_at:
+                return self._token
+
+            # tiny retry to dodge transient 403s
+            last_exc = None
+            for _ in range(2):
+                r = await self._client.post(
+                    f"{self.base_url}{self.oauth_path}",
+                    json={
+                        "grant_type": "client_credentials",
+                        "appkey": self.app_key,
+                        "appsecret": self.app_secret,
+                    },
+                )
+                try:
+                    r.raise_for_status()
+                    data = r.json()
+                    self._token = data["access_token"]
+                    ttl = int(data.get("expires_in", 86400)) - 300
+                    self._expires_at = datetime.now() + timedelta(seconds=max(ttl, 600))
+                    return self._token
+                except httpx.HTTPStatusError as e:
+                    last_exc = e
+                    await asyncio.sleep(0.2)  # brief backoff
+
+            # surface helpful message
+            detail = getattr(last_exc.response, "text", "")[:200].replace("\n", " ")
+            raise httpx.HTTPStatusError(
+                f"KIS token failed ({last_exc.response.status_code}). Hint: {detail}",
+                request=last_exc.request,
+                response=last_exc.response,
+            )
+
+    async def get(self, path: str, *, tr_id: str, params: Dict[str, Any]) -> dict:
+        token = await self._ensure_token()
+        headers = {
+            "Authorization": f"Bearer {token}",
+            "appkey": self.app_key,
+            "appsecret": self.app_secret,
+            "tr_id": tr_id,
+            "custtype": "P",
+        }
+        r = await self._client.get(
+            f"{self.base_url}{path}", params=params, headers=headers
+        )
+        r.raise_for_status()
+        data = r.json()
+        if data.get("rt_cd") != "0":
+            raise httpx.HTTPStatusError(
+                message=data.get("msg1", "KIS error"), request=r.request, response=r
+            )
+        return data
+
+    async def aclose(self):
+        await self._client.aclose()
diff --git a/packages/core/build/lib/core/clients/naver.py b/packages/core/build/lib/core/clients/naver.py
new file mode 100644
index 0000000..fe945ae
--- /dev/null
+++ b/packages/core/build/lib/core/clients/naver.py
@@ -0,0 +1,77 @@
+from __future__ import annotations
+import os
+import httpx
+from typing import Optional
+from datetime import datetime, timedelta
+from core.utils.cache import path, fresh, load_json, save_json
+
+NAVER_ID = os.getenv("NAVER_SEARCH_CLIENT_ID")
+NAVER_SECRET = os.getenv("NAVER_SEARCH_CLIENT_SECRET")
+
+
+async def company_logo(company_name: str, stock_code: str | None = None) -> str | None:
+    cache = path("logos", f"{company_name}.json")
+    if fresh(cache, days=30):
+        data = load_json(cache)
+        if data and data.get("logo_url") and data.get("logo_url") != "NO_LOGO":
+            return data["logo_url"]
+
+    if not stock_code or not NAVER_ID or not NAVER_SECRET:
+        return None
+
+    async with httpx.AsyncClient(timeout=5) as c:
+        r = await c.get(
+            "https://openapi.naver.com/v1/search/image",
+            headers={
+                "X-Naver-Client-Id": NAVER_ID,
+                "X-Naver-Client-Secret": NAVER_SECRET,
+            },
+            params={"query": f"{stock_code} tradingview", "display": 1, "sort": "sim"},
+        )
+        r.raise_for_status()
+        items = r.json().get("items", [])
+        logo_url = items[0]["link"] if items else "NO_LOGO"
+        save_json(
+            {
+                "company_name": company_name,
+                "logo_url": logo_url,
+                "expiry_date": (datetime.now() + timedelta(days=30)).isoformat(),
+            },
+            cache,
+        )
+        return None if logo_url == "NO_LOGO" else logo_url
+
+
+class NaverImageSearch:
+    def __init__(
+        self,
+        client_id: Optional[str],
+        client_secret: Optional[str],
+        *,
+        timeout: float = 5.0,
+    ):
+        self.client_id = client_id
+        self.client_secret = client_secret
+        self._client = httpx.AsyncClient(timeout=timeout)
+
+    def _enabled(self) -> bool:
+        return bool(self.client_id and self.client_secret)
+
+    async def search_one(self, query: str) -> str | None:
+        if not self._enabled():
+            # 자격 없으면 조용히 None
+            return None
+        r = await self._client.get(
+            "https://openapi.naver.com/v1/search/image",
+            headers={
+                "X-Naver-Client-Id": self.client_id,
+                "X-Naver-Client-Secret": self.client_secret,
+            },
+            params={"query": query, "display": 1, "sort": "sim"},
+        )
+        # 네이버 API는 200이어도 items 비어있을 수 있음
+        if r.status_code // 100 != 2:
+            return None
+        data = r.json()
+        items = data.get("items") or []
+        return items[0]["link"] if items else None
diff --git a/packages/core/build/lib/core/schemas/__init__.py b/packages/core/build/lib/core/schemas/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/packages/core/build/lib/core/schemas/financials.py b/packages/core/build/lib/core/schemas/financials.py
new file mode 100644
index 0000000..86e8bcf
--- /dev/null
+++ b/packages/core/build/lib/core/schemas/financials.py
@@ -0,0 +1,19 @@
+from pydantic import BaseModel
+from typing import List, Optional
+
+
+class FSRow(BaseModel):
+    account_id: Optional[str] = None
+    account_nm: Optional[str] = None
+    bsns_year: Optional[str] = None
+    thstrm_amount: Optional[str] = None
+    frmtrm_amount: Optional[str] = None
+    fs_div: Optional[str] = None
+    reprt_code: Optional[str] = None
+
+
+class FinancialStatement(BaseModel):
+    corp_code: str
+    year: int
+    report_name: Optional[str] = None
+    rows: List[FSRow] = []
diff --git a/packages/core/build/lib/core/schemas/prices.py b/packages/core/build/lib/core/schemas/prices.py
new file mode 100644
index 0000000..b1e19c8
--- /dev/null
+++ b/packages/core/build/lib/core/schemas/prices.py
@@ -0,0 +1,18 @@
+from pydantic import BaseModel
+from typing import List, Optional
+
+
+class PricePoint(BaseModel):
+    date: str
+    open: Optional[float] = None
+    high: Optional[float] = None
+    low: Optional[float] = None
+    close: Optional[float] = None
+    volume: Optional[float] = None
+    transaction_amount: Optional[float] = None
+    change: Optional[float] = None
+
+
+class PriceSeries(BaseModel):
+    ticker: str
+    points: List[PricePoint] = []
diff --git a/packages/core/build/lib/core/services/__init__.py b/packages/core/build/lib/core/services/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/packages/core/build/lib/core/services/analysis.py b/packages/core/build/lib/core/services/analysis.py
new file mode 100644
index 0000000..167bc50
--- /dev/null
+++ b/packages/core/build/lib/core/services/analysis.py
@@ -0,0 +1,302 @@
+from __future__ import annotations
+import logging
+from typing import Dict, Any
+import numpy as np
+import pandas as pd
+
+logger = logging.getLogger(__name__)
+
+# -----------------------------
+# Internal helpers
+# -----------------------------
+
+
+def _coerce_number(value: Any) -> float:
+    """Convert DART numeric strings like "1,234" → float, else NaN."""
+    try:
+        if value is None or (isinstance(value, float) and np.isnan(value)):
+            return np.nan
+        s = str(value).replace(",", "").strip()
+        if s == "" or s.lower() == "nan":
+            return np.nan
+        return float(s)
+    except Exception:
+        return np.nan
+
+
+def _get_account_value(fs_df: pd.DataFrame, account_name: str) -> float:
+    """Safely extract `thstrm_amount` for an exact account name from DART FS df."""
+    if fs_df is None or fs_df.empty:
+        return np.nan
+    if "account_nm" not in fs_df.columns:
+        return np.nan
+    try:
+        row = fs_df[fs_df["account_nm"] == account_name]
+        if row.empty:
+            return np.nan
+        value = row.iloc[0].get("thstrm_amount")
+        return _coerce_number(value)
+    except Exception:
+        return np.nan
+
+
+# -----------------------------
+# Public API (pure functions)
+# -----------------------------
+
+
+def dcf_intrinsic_price(
+    *, fcf0: float, growth: float, wacc: float, terminal_g: float, shares: float
+) -> float:
+    """5Y DCF + Gordon terminal; returns price per share."""
+    years = np.arange(1, 6)
+    fcfs = fcf0 * (1.0 + growth) ** years
+    pv_fcfs = (fcfs / (1.0 + wacc) ** years).sum()
+    terminal_value = (fcfs[-1] * (1.0 + terminal_g)) / (wacc - terminal_g)
+    pv_terminal = terminal_value / (1.0 + wacc) ** 5
+    equity_value = pv_fcfs + pv_terminal
+    return float(equity_value / shares) if shares else float("nan")
+
+
+def rim_intrinsic_price(
+    *,
+    bps: float,
+    roe: float,
+    cost_of_equity: float,
+    growth: float,
+    years: int,
+    shares: float,
+) -> float:
+    """Residual Income Model with BV compounding, returns price per share."""
+    bv = float(bps)
+    residuals: list[float] = []
+    for t in range(years):
+        ni = bv * roe
+        bv = bv + ni - (bv * growth)  # retain earnings; simplistic payout modelling
+        ri = ni - (cost_of_equity * bv)
+        residuals.append(ri)
+    pv_residuals = sum(
+        ri / (1.0 + cost_of_equity) ** (i + 1) for i, ri in enumerate(residuals)
+    )
+    intrinsic = bps + pv_residuals
+    return float(intrinsic / shares) if shares else float("nan")
+
+
+def calculate_financial_health(fs_df: pd.DataFrame) -> Dict[str, float | str]:
+    """Compute debt/current ratios, ROE, op margin, interest coverage, Z-score-ish, score & grade."""
+    if fs_df is None or fs_df.empty:
+        return {
+            "debt_ratio": np.nan,
+            "current_ratio": np.nan,
+            "roe": np.nan,
+            "op_margin": np.nan,
+            "interest_coverage": np.nan,
+            "z_score": np.nan,
+            "total_score": np.nan,
+            "grade": "N/A",
+        }
+
+    total_assets = _get_account_value(fs_df, "자산총계")
+    total_liabilities = _get_account_value(fs_df, "부채총계")
+    equity = _get_account_value(fs_df, "자본총계")
+    current_assets = _get_account_value(fs_df, "유동자산")
+    current_liabilities = _get_account_value(fs_df, "유동부채")
+    revenue = _get_account_value(fs_df, "매출액")
+    operating_income = _get_account_value(fs_df, "영업이익")
+    net_income = _get_account_value(fs_df, "당기순이익")
+    interest_expense = _get_account_value(fs_df, "이자비용")
+
+    debt_ratio = (total_liabilities / equity) * 100.0 if equity else np.nan
+    current_ratio = (
+        (current_assets / current_liabilities) * 100.0
+        if current_liabilities
+        else np.nan
+    )
+    roe = (net_income / equity) * 100.0 if equity else np.nan
+    op_margin = (operating_income / revenue) * 100.0 if revenue else np.nan
+    interest_coverage = (
+        (operating_income / interest_expense) if interest_expense else np.nan
+    )
+
+    def safe_div(a: float, b: float) -> float:
+        return a / b if (a is not None and b not in (None, 0, np.nan)) else np.nan
+
+    wca = safe_div(current_assets - current_liabilities, total_assets)
+    rea = safe_div(equity, total_assets)
+    eita = safe_div(operating_income, total_assets)
+    mvel = safe_div(equity, total_liabilities)
+    sta = safe_div(revenue, total_assets)
+
+    parts = [wca, rea, eita, mvel, sta]
+    z_score = (
+        (
+            (1.2 * (0.0 if np.isnan(wca) else wca))
+            + (1.4 * (0.0 if np.isnan(rea) else rea))
+            + (3.3 * (0.0 if np.isnan(eita) else eita))
+            + (0.6 * (0.0 if np.isnan(mvel) else mvel))
+            + (1.0 * (0.0 if np.isnan(sta) else sta))
+        )
+        if not all(np.isnan(x) for x in parts)
+        else np.nan
+    )
+
+    scores = {
+        "debt_ratio": max(
+            0.0, min(100.0, 100.0 - (debt_ratio if not np.isnan(debt_ratio) else 100.0))
+        ),
+        "current_ratio": max(
+            0.0, min(100.0, (current_ratio if not np.isnan(current_ratio) else 0.0))
+        ),
+        "roe": max(0.0, min(100.0, (roe if not np.isnan(roe) else 0.0))),
+        "op_margin": max(
+            0.0, min(100.0, (op_margin if not np.isnan(op_margin) else 0.0))
+        ),
+        "interest_coverage": max(
+            0.0,
+            min(
+                100.0,
+                (
+                    (interest_coverage * 10.0)
+                    if not np.isnan(interest_coverage)
+                    else 0.0
+                ),
+            ),
+        ),
+        "z_score": max(
+            0.0, min(100.0, ((z_score * 20.0) if not np.isnan(z_score) else 0.0))
+        ),
+    }
+
+    total_score = (
+        (
+            (scores["debt_ratio"] * 0.2)
+            + (scores["current_ratio"] * 0.2)
+            + (scores["roe"] * 0.2)
+            + (scores["op_margin"] * 0.15)
+            + (scores["interest_coverage"] * 0.15)
+            + (scores["z_score"] * 0.1)
+        )
+        if not all(np.isnan(v) for v in scores.values())
+        else np.nan
+    )
+
+    if np.isnan(total_score):
+        grade = "N/A"
+    elif total_score >= 80.0:
+        grade = "A"
+    elif total_score >= 60.0:
+        grade = "B"
+    else:
+        grade = "C"
+
+    return {
+        "debt_ratio": float(debt_ratio) if not np.isnan(debt_ratio) else np.nan,
+        "current_ratio": (
+            float(current_ratio) if not np.isnan(current_ratio) else np.nan
+        ),
+        "roe": float(roe) if not np.isnan(roe) else np.nan,
+        "op_margin": float(op_margin) if not np.isnan(op_margin) else np.nan,
+        "interest_coverage": (
+            float(interest_coverage) if not np.isnan(interest_coverage) else np.nan
+        ),
+        "z_score": float(z_score) if not np.isnan(z_score) else np.nan,
+        "total_score": float(total_score) if not np.isnan(total_score) else np.nan,
+        "grade": grade,
+    }
+
+
+def calculate_custom_ratios(
+    fs_df: pd.DataFrame, price_df: pd.DataFrame
+) -> Dict[str, float]:
+    """Compute PER, PBR, dividend yield from FS + latest price."""
+    if fs_df is None or fs_df.empty or price_df is None or price_df.empty:
+        return {"PER": np.nan, "PBR": np.nan, "배당수익률(%)": np.nan}
+
+    latest = price_df["close"].dropna()
+    latest_price = float(latest.iloc[-1]) if not latest.empty else np.nan
+    if np.isnan(latest_price):
+        return {"PER": np.nan, "PBR": np.nan, "배당수익률(%)": np.nan}
+
+    shares_outstanding = _get_account_value(fs_df, "발행주식수")
+    net_income = _get_account_value(fs_df, "당기순이익")
+    total_equity = _get_account_value(fs_df, "자본총계")
+    dividends = _get_account_value(fs_df, "배당금총액")
+
+    market_cap = (
+        latest_price * shares_outstanding
+        if (not np.isnan(latest_price) and not np.isnan(shares_outstanding))
+        else np.nan
+    )
+    per = (
+        (market_cap / net_income)
+        if (not np.isnan(market_cap) and not np.isnan(net_income) and net_income != 0)
+        else np.nan
+    )
+    pbr = (
+        (market_cap / total_equity)
+        if (
+            not np.isnan(market_cap)
+            and not np.isnan(total_equity)
+            and total_equity != 0
+        )
+        else np.nan
+    )
+    dy = (
+        ((dividends / market_cap) * 100.0)
+        if (not np.isnan(market_cap) and not np.isnan(dividends) and market_cap != 0)
+        else np.nan
+    )
+
+    return {
+        "PER": round(float(per), 2) if not np.isnan(per) else np.nan,
+        "PBR": round(float(pbr), 2) if not np.isnan(pbr) else np.nan,
+        "배당수익률(%)": round(float(dy), 2) if not np.isnan(dy) else np.nan,
+    }
+
+
+def compare_by_industry(df: pd.DataFrame) -> pd.DataFrame:
+    """Return simple mean of numeric columns grouped by '업종'."""
+    if df is None or df.empty or "업종" not in df.columns:
+        return pd.DataFrame()
+    numeric_cols = df.select_dtypes(include=np.number).columns.tolist()
+    if "업종" in numeric_cols:
+        numeric_cols.remove("업종")
+    if not numeric_cols:
+        return pd.DataFrame()
+    return df.groupby("업종")[numeric_cols].mean()
+
+
+def extract_fs_summary(fs_df: pd.DataFrame) -> Dict[str, float]:
+    """Pick a few headline FS metrics for a card view."""
+    if fs_df is None or fs_df.empty:
+        return {
+            "매출액": np.nan,
+            "영업이익": np.nan,
+            "당기순이익": np.nan,
+            "총자산": np.nan,
+            "총부채": np.nan,
+            "자본총계": np.nan,
+        }
+
+    def pick(key: str) -> float:
+        # use exact match first; fallback to contains
+        v = _get_account_value(fs_df, key)
+        if np.isnan(v):
+            try:
+                row = fs_df[
+                    fs_df["account_nm"].str.contains(key, na=False, regex=False)
+                ]
+                if not row.empty:
+                    return _coerce_number(row.iloc[0].get("thstrm_amount"))
+            except Exception:
+                pass
+        return v
+
+    return {
+        "매출액": pick("매출액"),
+        "영업이익": pick("영업이익"),
+        "당기순이익": pick("당기순이익"),
+        "총자산": pick("자산총계"),
+        "총부채": pick("부채총계"),
+        "자본총계": pick("자본총계"),
+    }
diff --git a/packages/core/build/lib/core/services/logo.py b/packages/core/build/lib/core/services/logo.py
new file mode 100644
index 0000000..6f165da
--- /dev/null
+++ b/packages/core/build/lib/core/services/logo.py
@@ -0,0 +1,41 @@
+from __future__ import annotations
+from datetime import datetime, timedelta
+from core.utils.cache import path, fresh, save_json, load_json
+from core.clients.naver import NaverImageSearch
+
+
+async def get_logo_cached(
+    naver: NaverImageSearch, *, company_name: str, stock_code: str | None = None
+) -> dict:
+    key = stock_code or company_name
+    cache_file = path("logos", f"{key}.json")
+
+    # 30일 캐시
+    if fresh(cache_file, days=30):
+        cached = load_json(cache_file)
+        if cached is not None:
+            return cached
+
+    # 자격 없으면 graceful degrade
+    if not (naver and naver.client_id and naver.client_secret):
+        data = {
+            "company": company_name,
+            "stock_code": stock_code,
+            "logo_url": None,
+            "cached": False,
+            "reason": "missing_naver_credentials",
+        }
+        save_json(data, cache_file)
+        return data
+
+    # 검색 쿼리: 우선 종목코드, 없으면 회사명
+    query = f"{stock_code} tradingview" if stock_code else f"{company_name} 로고"
+    url = await naver.search_one(query)
+    data = {
+        "company": company_name,
+        "stock_code": stock_code,
+        "logo_url": url,
+        "cached": False,
+    }
+    save_json(data, cache_file)
+    return data
diff --git a/packages/core/build/lib/core/services/lookup.py b/packages/core/build/lib/core/services/lookup.py
new file mode 100644
index 0000000..be2cf59
--- /dev/null
+++ b/packages/core/build/lib/core/services/lookup.py
@@ -0,0 +1,75 @@
+from __future__ import annotations
+import io, zipfile, os
+import pandas as pd
+import httpx
+from fastapi import HTTPException
+from core.utils.cache import path, fresh, save_parquet, load_parquet
+
+
+async def corp_table(api_key: str) -> pd.DataFrame:
+    """
+    Fetch DART corpCode.zip (XML inside) safely.
+    - Requires api_key (do NOT read env here).
+    - Falls back to cached parquet if DART returns non-zip payloads.
+    """
+    cache_file = path("corp_codes", "corp_code_list.parquet")
+    if fresh(cache_file, days=1):
+        df = load_parquet(cache_file)
+        if df is not None:
+            return df
+
+    url = f"https://opendart.fss.or.kr/api/corpCode.xml?crtfc_key={api_key}"
+    async with httpx.AsyncClient(timeout=25) as c:
+        r = await c.get(url)
+        r.raise_for_status()
+
+        # Guard: DART sometimes returns text (error) with 200
+        ctype = (r.headers.get("Content-Type") or "").lower()
+        is_zipish = "zip" in ctype or r.content[:2] == b"PK"
+        if not is_zipish:
+            # Fallback to cache if any
+            cached = load_parquet(cache_file)
+            if cached is not None:
+                return cached
+            snippet = r.text[:200].replace("\n", " ")
+            raise HTTPException(
+                status_code=502,
+                detail=f"DART corpCode not zip; response hint: {snippet}",
+            )
+
+        try:
+            with zipfile.ZipFile(io.BytesIO(r.content)) as z:
+                with z.open("CORPCODE.xml") as f:
+                    import xml.etree.ElementTree as ET
+
+                    tree = ET.parse(f)
+        except zipfile.BadZipFile as e:
+            cached = load_parquet(cache_file)
+            if cached is not None:
+                return cached
+            raise HTTPException(status_code=502, detail=f"DART zip parse failed: {e}")
+
+    root = tree.getroot()
+    rows = []
+    for e in root.findall("list"):
+        stock = (e.findtext("stock_code") or "").strip()
+        if not stock:
+            continue
+        rows.append((e.findtext("corp_code"), e.findtext("corp_name"), stock))
+    df = pd.DataFrame(rows, columns=["corp_code", "corp_name", "stock_code"])
+    df["stock_code"] = df["stock_code"].astype(str).str.zfill(6)
+    save_parquet(df, cache_file)
+    return df
+
+
+async def company_info_by_stock(stock_code: str, api_key: str) -> dict | None:
+    df = await corp_table(api_key)
+    row = df[df["stock_code"] == stock_code]
+    if row.empty:
+        return None
+    r = row.iloc[0]
+    return {
+        "corp_name": r["corp_name"],
+        "corp_code": r["corp_code"],
+        "stock_code": r["stock_code"],
+    }
diff --git a/packages/core/build/lib/core/services/market_data.py b/packages/core/build/lib/core/services/market_data.py
new file mode 100644
index 0000000..1c7c807
--- /dev/null
+++ b/packages/core/build/lib/core/services/market_data.py
@@ -0,0 +1,191 @@
+from __future__ import annotations
+import pandas as pd
+import asyncio
+from core.clients.kis import KISClient
+from core.clients.dart import DARTClient
+from core.utils.cache import path, fresh, save_parquet, load_parquet
+from core.schemas.financials import FinancialStatement, FSRow
+
+
+# ------------------
+# KIS: daily price
+# ------------------
+async def kis_daily_price(
+    kis: KISClient, stock_code: str, start_date: str, end_date: str
+) -> pd.DataFrame:
+    start_dt = pd.to_datetime(start_date)
+    end_dt = pd.to_datetime(end_date)
+    cache_file = path(
+        "prices", stock_code, f"kis_{start_dt:%Y%m%d}_{end_dt:%Y%m%d}.parquet"
+    )
+    if fresh(cache_file, days=1):
+        cached = load_parquet(cache_file)
+        if cached is not None:
+            return cached
+
+    data = await kis.get(
+        "/uapi/domestic-stock/v1/quotations/inquire-daily-price",
+        tr_id="FHKST01010400",
+        params={
+            "FID_COND_MRKT_DIV_CODE": "J",
+            "FID_INPUT_ISCD": stock_code,
+            "FID_INPUT_DATE_1": f"{start_dt:%Y%m%d}",
+            "FID_INPUT_DATE_2": f"{end_dt:%Y%m%d}",
+            "FID_PERIOD_DIV_CODE": "D",
+            "FID_ORG_ADJ_PRC": "1",
+        },
+    )
+
+    df = pd.DataFrame(data.get("output", []))
+    if df.empty:
+        return df
+
+    df = df.rename(
+        columns={
+            "stck_bsop_date": "date",
+            "stck_oprc": "open",
+            "stck_hgpr": "high",
+            "stck_lwpr": "low",
+            "stck_clpr": "close",
+            "acml_vol": "volume",
+            "acml_tr_pbmn": "transaction_amount",
+            "prdy_vrss": "change",
+        }
+    )
+
+    cols = [
+        c
+        for c in [
+            "date",
+            "open",
+            "high",
+            "low",
+            "close",
+            "volume",
+            "transaction_amount",
+            "change",
+        ]
+        if c in df.columns
+    ]
+    for c in cols:
+        if c != "date":
+            df[c] = pd.to_numeric(df[c], errors="coerce")
+    df["date"] = pd.to_datetime(df["date"], format="%Y%m%d").dt.strftime("%Y-%m-%d")
+    df = df[cols].sort_values("date").reset_index(drop=True)
+    save_parquet(df, cache_file)
+    return df
+
+
+# ------------------
+# DART: financials
+# ------------------
+REPORTS = [
+    ("11011", "사업보고서"),
+    ("11014", "3분기보고서"),
+    ("11012", "반기보고서"),
+    ("11013", "1분기보고서"),
+]
+FSDIVS = [("CFS", "연결"), ("OFS", "별도")]
+
+
+async def dart_financials(
+    dart: DARTClient, corp_code: str, year: int
+) -> FinancialStatement | None:
+    """Return the first available FS for (corp_code, year) with a friendly report name.
+    Caches raw rows as parquet for 7 days.
+    """
+    for rp_code, rp_name in REPORTS:
+        for fs_div, fs_name in FSDIVS:
+            cache_file = path(
+                "financials", corp_code, f"{year}_{rp_code}_{fs_div}.parquet"
+            )
+            if fresh(cache_file, days=7):
+                cached = load_parquet(cache_file)
+                if cached is not None:
+                    return FinancialStatement(
+                        corp_code=corp_code,
+                        year=year,
+                        report_name=f"{rp_name} - {fs_name}",
+                        rows=[FSRow(**r) for r in cached.to_dict(orient="records")],
+                    )
+
+            data = await dart.single_fs(corp_code, year, rp_code, fs_div)
+            if data.get("status") == "000" and data.get("list"):
+                df = pd.DataFrame(data["list"])  # store raw
+                save_parquet(df, cache_file)
+                return FinancialStatement(
+                    corp_code=corp_code,
+                    year=year,
+                    report_name=f"{rp_name} - {fs_name}",
+                    rows=[FSRow(**r) for r in data["list"]],
+                )
+    return None
+
+
+async def kis_prices_panel(
+    kis: KISClient, stock_codes: list[str], start_date: str, end_date: str
+) -> pd.DataFrame:
+    async def one(code: str) -> pd.Series:
+        df = await kis_daily_price(kis, code, start_date, end_date)
+        if df is None or df.empty:
+            return pd.Series(name=code, dtype=float)
+        s = df.set_index("date")["close"].astype(float)
+        s.index = pd.to_datetime(s.index)
+        s.name = code
+        return s
+
+    series_list = await asyncio.gather(*[one(c) for c in stock_codes])
+    panel = pd.concat(series_list, axis=1).sort_index()
+    returns = panel.pct_change().dropna(how="all")
+    return returns
+
+
+async def kis_financial_ratios(kis: KISClient, stock_code: str) -> pd.DataFrame:
+    data = await kis.get(
+        "/uapi/domestic-stock/v1/finance/financial-ratio",
+        tr_id="FHKST66430300",
+        params={
+            "fid_div_cls_code": "0",
+            "fid_cond_mrkt_div_code": "J",
+            "fid_input_iscd": stock_code,
+        },
+    )
+    df = pd.DataFrame(data.get("output", []))
+    if df.empty:
+        return df
+    cols = {
+        "stac_yymm": "결산년월",
+        "grs_rt": "매출총이익률",
+        "bsop_prfi_inrt": "영업이익률",
+        "thtr_ntin_inrt": "당기순이익률",
+        "roe_val": "ROE",
+        "eps": "EPS",
+        "bps": "BPS",
+        "pbr": "PBR",
+        "dvd_yd_rt": "배당수익률",
+    }
+    df = df[[k for k in cols if k in df.columns]].rename(columns=cols)
+    for c in df.columns:
+        if c != "결산년월":
+            df[c] = pd.to_numeric(df[c], errors="coerce")
+    return df
+
+
+async def kis_investment_opinion(kis: KISClient, stock_code: str) -> dict:
+    data = await kis.get(
+        "/uapi/domestic-stock/v1/quotations/invest-opinion",
+        tr_id="FHKST663300C0",
+        params={
+            "FID_COND_MRKT_DIV_CODE": "J",
+            "FID_COND_SCR_DIV_CODE": "16633",
+            "FID_INPUT_ISCD": stock_code,
+            "FID_INPUT_DATE_1": pd.Timestamp.today().strftime("%Y0101"),
+            "FID_INPUT_DATE_2": pd.Timestamp.today().strftime("%Y%m%d"),
+        },
+    )
+    out = (data.get("output") or [{}])[0]
+    return {
+        "opinion": out.get("invt_opnn"),
+        "target_price": float(out.get("hts_goal_prc") or 0.0),
+        "analyst_count": int(out.get("nm_of_analyst") or 0),
+    }
diff --git a/packages/core/build/lib/core/services/metrics.py b/packages/core/build/lib/core/services/metrics.py
new file mode 100644
index 0000000..ddb5f88
--- /dev/null
+++ b/packages/core/build/lib/core/services/metrics.py
@@ -0,0 +1,90 @@
+from __future__ import annotations
+import numpy as np
+import pandas as pd
+
+# Safe extract (matches legacy semantics)
+
+
+def extract_value(df: pd.DataFrame | None, account_name: str) -> float:
+    if df is None or df.empty:
+        return float("nan")
+    row = df[df["account_nm"] == account_name]
+    if row.empty:
+        return float("nan")
+    return float(pd.to_numeric(row.iloc[0].get("thstrm_amount"), errors="coerce"))
+
+
+def calculate_custom_metrics(
+    df_fs: pd.DataFrame | None, df_price: pd.DataFrame | None
+) -> dict:
+    if df_fs is None or df_fs.empty:
+        return {}
+    m = {
+        "revenue": extract_value(df_fs, "매출액"),
+        "operating_income": extract_value(df_fs, "영업이익"),
+        "net_income": extract_value(df_fs, "당기순이익"),
+        "total_assets": extract_value(df_fs, "자산총계"),
+        "total_liabilities": extract_value(df_fs, "부채총계"),
+        "total_equity": extract_value(df_fs, "자본총계"),
+    }
+    if df_price is not None and not df_price.empty:
+        m["latest_close_price"] = float(
+            pd.to_numeric(df_price["close"].iloc[-1], errors="coerce")
+        )
+    return m
+
+
+# Piotroski F-score
+
+
+def calculate_piotroski_f_score(
+    df_curr: pd.DataFrame | None, df_prev: pd.DataFrame | None
+) -> tuple[int, dict]:
+    MAP = {
+        "NI": "당기순이익",
+        "CFO": "영업활동으로인한현금흐름",
+        "TA": "자산총계",
+        "TL": "부채총계",
+        "CA": "유동자산",
+        "CL": "유동부채",
+        "REV": "매출액",
+        "COGS": "매출원가",
+        "SHARES": "유통주식수",
+    }
+
+    def v(df: pd.DataFrame | None, key: str) -> float:
+        if df is None or df.empty:
+            return float("nan")
+        row = df[df["account_nm"] == MAP[key]]
+        return (
+            float(pd.to_numeric(row["thstrm_amount"].iloc[0], errors="coerce"))
+            if not row.empty
+            else float("nan")
+        )
+
+    if df_curr is None or df_prev is None:
+        return 0, {}
+
+    detail: dict[str, int] = {}
+    roa_c = v(df_curr, "NI") / v(df_curr, "TA")
+    detail["1. ROA > 0"] = int(roa_c > 0)
+    cfo_c = v(df_curr, "CFO")
+    detail["2. CFO > 0"] = int(cfo_c > 0)
+    roa_p = v(df_prev, "NI") / v(df_prev, "TA")
+    detail["3. ROA 증가"] = int(roa_c > roa_p)
+    detail["4. CFO > NI"] = int(cfo_c > v(df_curr, "NI"))
+    lev_c = v(df_curr, "TL") / v(df_curr, "TA")
+    lev_p = v(df_prev, "TL") / v(df_prev, "TA")
+    detail["5. 레버리지 비율 감소"] = int(lev_c < lev_p)
+    cr_c = v(df_curr, "CA") / v(df_curr, "CL")
+    cr_p = v(df_prev, "CA") / v(df_prev, "CL")
+    detail["6. 유동비율 증가"] = int(cr_c > cr_p)
+    detail["7. 신주발행 없음"] = int(v(df_curr, "SHARES") <= v(df_prev, "SHARES"))
+    gm_c = (v(df_curr, "REV") - v(df_curr, "COGS")) / v(df_curr, "REV")
+    gm_p = (v(df_prev, "REV") - v(df_prev, "COGS")) / v(df_prev, "REV")
+    detail["8. 총이익률 증가"] = int(gm_c > gm_p)
+    at_c = v(df_curr, "REV") / v(df_curr, "TA")
+    at_p = v(df_prev, "REV") / v(df_prev, "TA")
+    detail["9. 자산회전율 증가"] = int(at_c > at_p)
+
+    return int(sum(detail.values())), detail
diff --git a/packages/core/build/lib/core/services/portfolio.py b/packages/core/build/lib/core/services/portfolio.py
new file mode 100644
index 0000000..45d85ba
--- /dev/null
+++ b/packages/core/build/lib/core/services/portfolio.py
@@ -0,0 +1,158 @@
+from __future__ import annotations
+import numpy as np
+import pandas as pd
+from scipy.optimize import minimize
+
+ANNUALIZATION_FACTOR = 252
+DEFAULT_RISK_FREE_RATE = 0.02
+
+# ----------------- helpers -----------------
+
+
+def _annualized(
+    mu_daily: np.ndarray, cov_daily: np.ndarray
+) -> tuple[np.ndarray, np.ndarray]:
+    return mu_daily * ANNUALIZATION_FACTOR, cov_daily * ANNUALIZATION_FACTOR
+
+
+# API-safe version of legacy calculate_portfolio_performance
+
+
+def calculate_portfolio_performance(
+    weights: np.ndarray, mean_returns: pd.Series, cov_matrix: pd.DataFrame
+) -> tuple[float, float]:
+    if (
+        not isinstance(weights, np.ndarray)
+        or weights.ndim != 1
+        or len(weights) != len(mean_returns)
+    ):
+        return np.nan, np.nan
+    if mean_returns.empty or cov_matrix.empty:
+        return np.nan, np.nan
+    try:
+        mu_ann, cov_ann = _annualized(mean_returns.to_numpy(), cov_matrix.to_numpy())
+        ret = float(np.sum(mu_ann * weights))
+        vol = float(np.sqrt(weights.T @ cov_ann @ weights))
+        return vol, ret
+    except Exception:
+        return np.nan, np.nan
+
+
+# legacy-compatible negative Sharpe
+
+
+def negative_sharpe_ratio(
+    weights: np.ndarray,
+    mean_returns: pd.Series,
+    cov_matrix: pd.DataFrame,
+    risk_free_rate: float = DEFAULT_RISK_FREE_RATE,
+) -> float:
+    vol, ret = calculate_portfolio_performance(weights, mean_returns, cov_matrix)
+    if np.isnan(vol) or vol == 0:
+        return np.inf
+    return -((ret - risk_free_rate) / vol)
+
+
+# ----------------- optimizers -----------------
+
+
+def optimize_portfolio(
+    returns_df: pd.DataFrame, risk_free_rate: float = DEFAULT_RISK_FREE_RATE
+) -> dict:
+    if returns_df is None or returns_df.empty:
+        return {
+            "weights": None,
+            "annual_return": np.nan,
+            "annual_volatility": np.nan,
+            "sharpe_ratio": np.nan,
+            "success": False,
+        }
+
+    mean_returns = returns_df.mean()
+    cov_matrix = returns_df.cov()
+    n = len(mean_returns)
+
+    constraints = {"type": "eq", "fun": lambda x: np.sum(x) - 1}
+    bounds = tuple((0.0, 1.0) for _ in range(n))  # long-only
+    x0 = np.full(n, 1.0 / n)
+
+    res = minimize(
+        negative_sharpe_ratio,
+        x0,
+        args=(mean_returns, cov_matrix, risk_free_rate),
+        method="SLSQP",
+        bounds=bounds,
+        constraints=constraints,
+        options={"maxiter": 100, "ftol": 1e-9},
+    )
+
+    if not res.success:
+        return {
+            "weights": None,
+            "annual_return": np.nan,
+            "annual_volatility": np.nan,
+            "sharpe_ratio": np.nan,
+            "success": False,
+        }
+
+    w = np.asarray(res.x, dtype=float)
+    vol, ret = calculate_portfolio_performance(w, mean_returns, cov_matrix)
+    sharpe = float((ret - risk_free_rate) / vol) if vol else np.nan
+
+    return {
+        "weights": w,
+        "annual_return": ret,
+        "annual_volatility": vol,
+        "sharpe_ratio": sharpe,
+        "success": True,
+    }
+
+
+# ----------------- backtest -----------------
+
+
+def backtest_portfolio(price_data: pd.DataFrame, weights: np.ndarray) -> dict:
+    if price_data is None or price_data.empty or weights is None or len(weights) == 0:
+        return {
+            "cumulative_returns": pd.Series(dtype=float),
+            "annual_return": np.nan,
+            "annual_volatility": np.nan,
+            "sharpe_ratio": np.nan,
+            "max_drawdown": np.nan,
+        }
+
+    price = price_data.sort_index().ffill().bfill()
+    rets = price.pct_change().dropna()
+    if rets.empty or len(weights) != rets.shape[1]:
+        return {
+            "cumulative_returns": pd.Series(dtype=float),
+            "annual_return": np.nan,
+            "annual_volatility": np.nan,
+            "sharpe_ratio": np.nan,
+            "max_drawdown": np.nan,
+        }
+
+    port_rets = (rets * weights).sum(axis=1)
+    cum = (1.0 + port_rets).cumprod()
+
+    ann_ret = (
+        float(cum.iloc[-1] ** (ANNUALIZATION_FACTOR / len(rets)) - 1.0)
+        if len(rets)
+        else np.nan
+    )
+    ann_vol = (
+        float(port_rets.std() * np.sqrt(ANNUALIZATION_FACTOR)) if len(rets) else np.nan
+    )
+    sharpe = float((ann_ret - DEFAULT_RISK_FREE_RATE) / ann_vol) if ann_vol else np.nan
+
+    peak = cum.expanding(min_periods=1).max()
+    dd = (cum - peak) / peak
+    mdd = float(dd.min()) if not dd.empty else np.nan
+
+    return {
+        "cumulative_returns": cum,
+        "annual_return": ann_ret,
+        "annual_volatility": ann_vol,
+        "sharpe_ratio": sharpe,
+        "max_drawdown": mdd,
+    }
diff --git a/packages/core/build/lib/core/utils/__init__.py b/packages/core/build/lib/core/utils/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/packages/core/build/lib/core/utils/cache.py b/packages/core/build/lib/core/utils/cache.py
new file mode 100644
index 0000000..e680b33
--- /dev/null
+++ b/packages/core/build/lib/core/utils/cache.py
@@ -0,0 +1,50 @@
+from __future__ import annotations
+import os, json
+from datetime import datetime, timedelta
+import pandas as pd
+from typing import Any
+
+BASE = os.getenv("CORE_CACHE_DIR", os.path.join("data", "cache"))
+
+
+def path(*parts: str) -> str:
+    p = os.path.join(BASE, *parts)
+    os.makedirs(os.path.dirname(p), exist_ok=True)
+    return p
+
+
+def fresh(p: str, days: int = 1) -> bool:
+    if not os.path.exists(p):
+        return False
+    mt = datetime.fromtimestamp(os.path.getmtime(p))
+    return (datetime.now() - mt) < timedelta(days=days)
+
+
+# JSON helpers
+
+
+def save_json(obj: Any, p: str) -> None:
+    with open(p, "w", encoding="utf-8") as f:
+        json.dump(obj, f, ensure_ascii=False, indent=2)
+
+
+def load_json(p: str) -> Any | None:
+    try:
+        with open(p, "r", encoding="utf-8") as f:
+            return json.load(f)
+    except Exception:
+        return None
+
+
+# Parquet helpers
+
+
+def save_parquet(df: pd.DataFrame, p: str) -> None:
+    df.to_parquet(p, index=False)
+
+
+def load_parquet(p: str) -> pd.DataFrame | None:
+    try:
+        return pd.read_parquet(p)
+    except Exception:
+        return None
diff --git a/services/api/financial_api.egg-info/PKG-INFO b/services/api/financial_api.egg-info/PKG-INFO
index d4f4c7b..b7991a3 100644
--- a/services/api/financial_api.egg-info/PKG-INFO
+++ b/services/api/financial_api.egg-info/PKG-INFO
@@ -5,4 +5,4 @@ Requires-Python: >=3.10
 Requires-Dist: fastapi>=0.112
 Requires-Dist: uvicorn[standard]>=0.30
 Requires-Dist: python-dotenv>=1.0
-Requires-Dist: financial-core@ file:///${PROJECT_ROOT}/packages/core
+Requires-Dist: financial-core@ file:///C:/workspace/kiwoom-python/financial_project/packages/core
diff --git a/services/api/financial_api.egg-info/requires.txt b/services/api/financial_api.egg-info/requires.txt
index a905355..c82cfe9 100644
--- a/services/api/financial_api.egg-info/requires.txt
+++ b/services/api/financial_api.egg-info/requires.txt
@@ -1,4 +1,4 @@
 fastapi>=0.112
 uvicorn[standard]>=0.30
 python-dotenv>=1.0
-financial-core@ file:///${PROJECT_ROOT}/packages/core
+financial-core@ file:///C:/workspace/kiwoom-python/financial_project/packages/core
diff --git a/services/api/pyproject.toml b/services/api/pyproject.toml
index d663b3f..d03444e 100644
--- a/services/api/pyproject.toml
+++ b/services/api/pyproject.toml
@@ -10,9 +10,20 @@ dependencies = [
   "fastapi>=0.112",
   "uvicorn[standard]>=0.30",
   "python-dotenv>=1.0",
-  "financial-core @ file:///${PROJECT_ROOT}/packages/core"
+  "financial-core @ file:///C:/workspace/kiwoom-python/financial_project/packages/core"
 ]
 
 [tool.setuptools]
 packages = ["app"]
-include-package-data = true
\ No newline at end of file
+include-package-data = true
+
+[tool.ruff]
+line-length = 100
+exclude = [
+  "packages/core/build",
+  "dist",
+  "*.egg-info",
+]
+
+[tool.ruff.lint]
+select = ["E", "F", "I"]
\ No newline at end of file
